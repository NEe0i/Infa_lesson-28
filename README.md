# Infa_lesson-28 
1. нужно сложить соответствующие разряды столбиком, начиная с младшего разряда. Если в полученной сумме есть разряд, который больше 1, то в текущий разряд результата записывается последняя цифра этой суммы, а в следующий разряд переносится 1
2. наиболее распространённый способ представления отрицательных целых чисел в компьютерах,  инвестировать все биты
3. Причиной переполнения может служить суммирование двух чисел с одинаковыми знаками, которые в сумме дают величину, большую или равную 1 и величины rn
4. Арифмеетико-логическое устроойство
5. В большинстве компьютеров операция вычитания не используется
6. нет
7. Сложение и вычитание требуются не только для расчётов по формулам, но и для организации вычислений
8. Поразрядные операции выполняются над отдельными разрядами или битами чисел. Данные операции производятся только над целыми числами
9. Потому что это разные операции
10. последовательность букв, цифр и прочих допустимых в именах файлов символов
11. Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать
12. взять и убрать
13. Для сброса конкретного бита, не трогая другие, нужно выполнить битовое AND с маской типа 11111011. А маску такую чтобы сделать - можно, например, выполнить сдвиг единицы влево, затем инвертировать
14. Взять и убрать
15. с помощью маски
16. Установка или сброс битов двоичного кода может быть использована, например, в задачах контроля доступа, кодирования информации, определения состояния устройств, изменения настроек и т.д
17. Замкнусть, ассоциативность, Коммутативность, существование нулевого элемента
18. Применяем операцию "исключающее ИЛИ" между ключевой маской и исходным сообщением.
19. исключающее ИЛИ
20. Применение операции "НЕ" к числу инвертирует каждый бит числа
21. ИСКЛЮЧАЮЩЕЕ ИЛИ
22. это перемещение всех битов первого операнда влево или вправо на число, заданное вторым операндом,
23. при арифметическом сдвиге вправо самый старший бит сохраняется, при логическом сдвиге вправо - самый старший бит заполняется нулем, а при циклическом сдвиге вправо - самый старший бит становится младшим
24. Сдвиг влево двоичного кода удваивает число, потому что при каждом сдвиге влево каждый разряд умножается на 2. Сдвиг вправо уменьшает число вдвое, потому что при каждом сдвиге вправо каждый разряд делится на 2
25. Логический сдвиг не годится для уменьшения в два раза отрицательных чисел, потому что он не сохраняет знак числа. Арифметический сдвиг, в отличие от логического, сохраняет знак числа. При арифметическом сдвиге вправо отрицательные числа уменьшаются вдвое, а при сдвиге влево увеличиваются вдвое
26. р
27. Каждый разряд числа сдвигается на один разряд вправо
28. р

ЗАДАЧИ 

1. 00011111^2 + 00010011^2 = 00110010^2 
2. 11100001^2 + 00010011^2 = 11110100^2 
3. Задача №3 ответ,.
4. 1011111^2; 11011111^2 
5. 1100^2 ⋅ 111^2 = 1010100^2 
6. 11110100^2 ⋅ 111^2 = 10101100^2 
7. Коля  просто  догадался  применить  переместительный  закон  для  умножения,  переставив  
сомножители. 
8. 119 и 136, 119 и –120 
9. кодЗаглавной = кодСтрочной and DF^16 
10. кодСтрочной = кодЗаглавной or 20^16 
11. Решение Коли приводит к неправильным ответам, когда сумма цифр больше 15. 
12. 4, 8, 16 – все они делятся нацело на 4 
13. X and1 = 0 , X and 7 = 0 , X and F = 0 , 
14. a:=a xor b; b:=b xor a; a:=a xor b; 
15. R:= X shr 16; G:=(X shr 8) & F^16; B:= X & F^16; 
16. Правильны оба решения, но у Коли рациональнее. 
17. Y:=(X shl 4) shr 4; Z:=(X shr 4) shl 4; 
18. При использовании 16‐битных данных: EDC0^16, EDCF^16.
19. При использовании 16‐битных данных: 0123^16, 4123^16, 0123^16; 0FED^16, CFED^16, FFED^16 
20. EE16, 7716 = 119 = (256 – 18)/2, F716 = –9 
21. FF^16, FF^16, FF^16 
22. Z = 11002 = 12 
Z = Z shl 1 = 11000^2 
X = Z = 11000^2 
X = X shl 2 = 1100000^2 
X = X + Z = 1111000^2 = 120 00011111^2 + 00010011^2 = 00110010^2 
